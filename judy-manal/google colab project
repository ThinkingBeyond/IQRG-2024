Grover's_Algorithm_Manal_Judy_.ipynb
{
  "nbformat": 4,
  "nbformat_minor": 0,
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyPMPUQUw1xUiQokV6LZSWJV",
      "include_colab_link": true
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/mnalhkem/mnalhkem/blob/main/Grover's_Algorithm_Manal_Judy_.ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from qiskit import QuantumCircuit, execute, Aer\n",
        "\n",
        "# Define the target value\n",
        "target = 46\n",
        "\n",
        "# Define the range of N values\n",
        "N_values = [2**i for i in range(3, 10)]  # N = 8, 16, 32,..., 1024\n",
        "\n",
        "# Define the number of oracle calls for classical search\n",
        "classical_oracle_calls = [N / 2 for N in N_values]\n",
        "\n",
        "# Define the number of oracle calls for Grover's search\n",
        "# The prefactor of π/4 comes from the analysis of Grover's algorithm,\n",
        "# where the expected number of iterations is π/4 * √N\n",
        "grover_oracle_calls = [int(np.pi/4 * np.sqrt(N)) for N in N_values]\n",
        "\n",
        "# Create a figure and axis\n",
        "fig, ax = plt.subplots()\n",
        "\n",
        "# Plot the number of oracle calls for classical search\n",
        "ax.plot(N_values, classical_oracle_calls, label='Classical Search')\n",
        "\n",
        "# Plot the number of oracle calls for Grover's search\n",
        "ax.plot(N_values, grover_oracle_calls, label=\"Grover's Search\")\n",
        "\n",
        "# Set the x-axis label\n",
        "ax.set_xlabel('System Size N')\n",
        "\n",
        "# Set the y-axis label\n",
        "ax.set_ylabel('Number of Oracle Calls')\n",
        "\n",
        "# Set the title\n",
        "ax.set_title(\"Theoretical Efficiency of Grover's Search Algorithm\")\n",
        "\n",
        "# Show the legend\n",
        "ax.legend()\n",
        "\n",
        "# Show the plot\n",
        "plt.show()\n",
        "\n",
        "# Define a function to implement Grover's algorithm\n",
        "def grovers_algorithm(N, target):\n",
        "    # Create a quantum circuit with N qubits and N classical bits\n",
        "    qc = QuantumCircuit(N, N)\n",
        "\n",
        "    # Apply Hadamard gates to all qubits\n",
        "    for i in range(N):\n",
        "        qc.h(i)\n",
        "\n",
        "    # Apply the oracle\n",
        "    oracle(qc, N, target)\n",
        "\n",
        "    # Apply the diffusion operator\n",
        "    diffusion(qc, N)\n",
        "\n",
        "    # Measure the qubits\n",
        "    qc.measure(range(N), range(N))\n",
        "\n",
        "    # Execute the circuit\n",
        "    job = execute(qc, Aer.get_backend('qasm_simulator'), shots=1)\n",
        "    result = job.result()\n",
        "    counts = result.get_counts(qc)\n",
        "\n",
        "    # Return the result\n",
        "    return counts\n",
        "\n",
        "# Define the oracle function\n",
        "def oracle(qc, N, target):\n",
        "    # Create a binary representation of the target value\n",
        "    target_bin = format(target, 'b').zfill(N)\n",
        "\n",
        "    # Apply the oracle gate\n",
        "    for i in range(N):\n",
        "        if target_bin[i] == '1':\n",
        "            qc.x(i)\n",
        "\n",
        "    # Apply a phase shift\n",
        "    for i in range(N):\n",
        "        qc.rz(-np.pi/2, i)\n",
        "\n",
        "    # Apply the oracle gate again\n",
        "    for i in range(N):\n",
        "        if target_bin[i] == '1':\n",
        "            qc.x(i)\n",
        "\n",
        "# Define the diffusion operator\n",
        "def diffusion(qc, N):\n",
        "    # Apply Hadamard gates to all qubits\n",
        "    for i in range(N):\n",
        "        qc.h(i)\n",
        "\n",
        "    # Apply a phase shift\n",
        "    for i in range(N):\n",
        "        qc.rz(np.pi, i)\n",
        "\n",
        "    # Apply Hadamard gates to all qubits again\n",
        "    for i in range(N):\n",
        "        qc.h(i)\n",
        "\n",
        "# Run Grover's algorithm for N = 100\n",
        "N = 100\n",
        "counts = grovers_algorithm(N, target)\n",
        "print(\"Result:\", counts)"
      ],
      "metadata": {
        "id": "tfIoUBgQlCwD"
      },
      "execution_count": null,
      "outputs": []
    }
  ]
}